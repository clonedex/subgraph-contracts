{
  "language": "Solidity",
  "sources": {
    "contracts/ConverterRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.4.24;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public view returns (address) {}\n\n    function transferOwnership(address _newOwner) public;\n    function acceptOwnership() public;\n}\n\n\n\n/*\n    Provides support and utilities for contract ownership\n*/\ncontract Owned is IOwned {\n    address public owner;\n    address public newOwner;\n\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n\n    /**\n        @dev constructor\n    */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n        @dev allows transferring the contract ownership\n        the new owner still needs to accept the transfer\n        can only be called by the contract owner\n\n        @param _newOwner    new contract owner\n    */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n\n    /**\n        @dev used by a new owner to accept an ownership transfer\n    */\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n/*\n    Utilities & Common Modifiers\n*/\ncontract Utils {\n    /**\n        constructor\n    */\n    constructor() public {\n    }\n\n    // verifies that an amount is greater than zero\n    modifier greaterThanZero(uint256 _amount) {\n        require(_amount > 0);\n        _;\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n}\n\n\n\n\n/**\n    Bancor Converter Registry\n\n    The bancor converter registry keeps converter addresses by token addresses and vice versa.\n    The owner can update converter addresses so that a the token address always points to\n    the updated list of converters for each token.\n\n    The contract also allows to iterate through all the tokens in the network.\n\n    Note that converter addresses for each token are returned in ascending order (from oldest\n    to latest).\n*/\ncontract BancorConverterRegistry is Owned, Utils {\n    mapping (address => bool) private tokensRegistered;         // token address -> registered or not\n    mapping (address => address[]) private tokensToConverters;  // token address -> converter addresses\n    mapping (address => address) private convertersToTokens;    // converter address -> token address\n    address[] public tokens;                                    // list of all token addresses\n\n    // triggered when a converter is added to the registry\n    event ConverterAddition(address indexed _token, address _address);\n\n    // triggered when a converter is removed from the registry\n    event ConverterRemoval(address indexed _token, address _address);\n\n    /**\n        @dev constructor\n    */\n    constructor() public {\n    }\n\n    /**\n        @dev returns the number of tokens in the registry\n\n        @return number of tokens\n    */\n    function tokenCount() public view returns (uint256) {\n        return tokens.length;\n    }\n\n    /**\n        @dev returns the number of converters associated with the given token\n        or 0 if the token isn't registered\n\n        @param _token   token address\n\n        @return number of converters\n    */\n    function converterCount(address _token) public view returns (uint256) {\n        return tokensToConverters[_token].length;\n    }\n\n    /**\n        @dev returns the converter address associated with the given token\n        or zero address if no such converter exists\n\n        @param _token   token address\n        @param _index   converter index\n\n        @return converter address\n    */\n    function converterAddress(address _token, uint32 _index) public view returns (address) {\n        if (_index >= tokensToConverters[_token].length)\n            return address(0);\n\n        return tokensToConverters[_token][_index];\n    }\n\n    /**\n        @dev returns the token address associated with the given converter\n        or zero address if no such converter exists\n\n        @param _converter   converter address\n\n        @return token address\n    */\n    function tokenAddress(address _converter) public view returns (address) {\n        return convertersToTokens[_converter];\n    }\n\n    /**\n        @dev adds a new converter address for a given token to the registry\n        throws if the converter is already registered\n\n        @param _token       token address\n        @param _converter   converter address\n    */\n    function registerConverter(address _token, address _converter)\n        public\n        ownerOnly\n        validAddress(_token)\n        validAddress(_converter)\n    {\n        require(convertersToTokens[_converter] == address(0));\n\n        // add the token to the list of tokens\n        if (!tokensRegistered[_token]) {\n            tokens.push(_token);\n            tokensRegistered[_token] = true;\n        }\n\n        tokensToConverters[_token].push(_converter);\n        convertersToTokens[_converter] = _token;\n\n        // dispatch the converter addition event\n        emit ConverterAddition(_token, _converter);\n    }\n\n    /**\n        @dev removes an existing converter from the registry\n        note that the function doesn't scale and might be needed to be called\n        multiple times when removing an older converter from a large converter list\n\n        @param _token   token address\n        @param _index   converter index\n    */\n    function unregisterConverter(address _token, uint32 _index)\n        public\n        ownerOnly\n        validAddress(_token)\n    {\n        require(_index < tokensToConverters[_token].length);\n\n        address converter = tokensToConverters[_token][_index];\n\n        // move all newer converters 1 position lower\n        for (uint32 i = _index + 1; i < tokensToConverters[_token].length; i++) {\n            tokensToConverters[_token][i - 1] = tokensToConverters[_token][i];\n        }\n\n        // decrease the number of converters defined for the token by 1\n        tokensToConverters[_token].length--;\n        \n        // removes the converter from the converters -> tokens list\n        delete convertersToTokens[converter];\n\n        // dispatch the converter removal event\n        emit ConverterRemoval(_token, converter);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}